// audit/scanWorkflowsForSecrets
// Scans ALL vRO workflows for hard-coded secrets in scriptable tasks + unencrypted-looking attributes.
// Inputs:
//   vroHost        : REST:RESTHost   // base https://<your-vro-host> (with or without /vco/api)
//   maxPageSize    : number = 200    // paging size
//   throttleMs     : number = 0      // optional sleep between page fetches to be gentle on the API
//   extraRegexes   : any    = null   // string or array of strings -> extra patterns
//   verbose        : boolean = true  // super-detailed per-item logs
//
// Output: Array of Properties (one per finding). Also prints rich logs.
//
// NOTE: No email. Pure logs + returned findings.

if (typeof maxPageSize === "undefined" || !maxPageSize) maxPageSize = 200;
if (typeof throttleMs === "undefined" || throttleMs === null) throttleMs = 0;
if (typeof verbose === "undefined") verbose = true;

function nowIso() {
  return new Date().toISOString();
}
function sleep(ms) {
  if (!ms || ms <= 0) return;
  try { Packages.java.lang.Thread.sleep(ms); } catch (e) {}
}
function safeStr(x) {
  return (x === null || x === undefined) ? "" : (x + "");
}
function b64decode(s) {
  try {
    var bytes = Packages.java.util.Base64.getDecoder().decode(String(s));
    return new java.lang.String(bytes, "UTF-8") + "";
  } catch (e) { return s + ""; }
}
function mkSnippet(txt, idx, patLen) {
  var start = Math.max(0, idx - 80);
  var end   = Math.min(txt.length, idx + patLen + 80);
  var snip = txt.substring(start, end).replace(/\r?\n/g, " ");
  return (start>0?"…":"") + snip + (end<txt.length?"…":"");
}
function lineCol(text, index) {
  // returns {line:1-based, col:1-based}
  var line = 1, col = 1;
  for (var i=0;i<text.length && i<index;i++) {
    var ch = text.charAt(i);
    if (ch === "\n") { line++; col = 1; } else { col++; }
  }
  return {line: line, col: col};
}

// ---------- Secret Patterns ----------
var patterns = [
  // Names/assignments like pwd/secret/token/apiKey = "value"
  /(?i)\b(pass(word|wd)?|pwd|secret|token|apikey|api_key|x-api-key|bearer)\s*[:=]\s*['"][^'"]+['"]/,
  /(?i)\b(pass(word|wd)?|pwd)\b\s*=\s*['"][^'"]+['"]/,

  // Cloud keys
  /AKIA[0-9A-Z]{16}/,                                                // AWS Access Key ID
  /(?i)aws(.{0,15})?(secret|key)\W{0,3}['"][A-Za-z0-9\/+=]{40}['"]/, // AWS Secret nearby
  /-----BEGIN (RSA |EC )?PRIVATE KEY-----/,
  /ssh-(rsa|ed25519) [A-Za-z0-9+\/=]+/,

  // Azure/GCP-ish & generic tokens
  /(?i)(accountkey|sharedaccesssignature|sas)\s*=/,
  /(?i)(client_secret|serviceAccountKey|private_key)\s*[:=]/,
  /(?i)(Authorization|Proxy-Authorization)\s*:\s*Bearer\s+[A-Za-z0-9\-_.+/=]+/
];

// Allow caller to extend
if (extraRegexes) {
  if (extraRegexes instanceof Array) {
    for (var i=0;i<extraRegexes.length;i++) {
      try { patterns.push(new RegExp(extraRegexes[i])); } catch (e) { System.warn("Bad extra regex["+i+"]: " + extraRegexes[i]); }
    }
  } else {
    try { patterns.push(new RegExp(extraRegexes)); } catch (e) { System.warn("Bad extra regex: " + extraRegexes); }
  }
}

var base = safeStr(vroHost.url);
var needsPrefix = base.indexOf("/vco/api") === -1;
var api = needsPrefix ? "/vco/api" : "";

// ------------- REST helpers -------------
function getJson(path) {
  var req = vroHost.createRequest("GET", path, null);
  req.setHeader("Accept", "application/json");
  var t0 = Packages.java.lang.System.nanoTime();
  var resp = req.execute();
  var dtMs = Math.round((Packages.java.lang.System.nanoTime() - t0) / 1e6);
  var code = resp.statusCode;
  System.log("HTTP GET " + path + " -> " + code + " (" + dtMs + " ms)");
  if (code < 200 || code >= 300) {
    throw "HTTP "+code+" for " + path + ": " + resp.contentAsString;
  }
  var body = resp.contentAsString;
  try {
    return JSON.parse(body);
  } catch (e) {
    throw "JSON parse error for " + path + ": " + e + " | body head=" + body.substring(0, 200);
  }
}

// ------------- Discovery -------------
function listAllWorkflows() {
  System.log("==> Listing workflows (page size=" + maxPageSize + ")");
  var results = [];
  var start = 0;
  var total = null;
  var pageNum = 0;
  do {
    pageNum++;
    var path = api + "/workflows?startIndex=" + start + "&maxResult=" + maxPageSize + "&queryCount=true";
    var page = getJson(path);
    if (total === null) total = page.total || 0;
    var links = page.link || [];
    System.log("Page " + pageNum + ": received " + links.length + " items (startIndex=" + start + ", total=" + total + ")");
    for (var i=0;i<links.length;i++) {
      var href = safeStr(links[i].href); // .../vco/api/workflows/<id>
      var id = href.replace(/^.*\/workflows\//, "");
      var name = null, category = null, version = null;
      var attrs = links[i].attribute || [];
      for (var a=0;a<attrs.length;a++) {
        if (attrs[a].name === "name") name = attrs[a].value;
        if (attrs[a].name === "categoryName") category = attrs[a].value;
        if (attrs[a].name === "version") version = attrs[a].value;
      }
      results.push({id:id, name:name || id, category: category || "", version: version || ""});
    }
    start += maxPageSize;
    if (throttleMs) sleep(throttleMs);
  } while (start < (total||0));
  System.log("==> Total workflows discovered: " + results.length);
  return results;
}

// ------------- Scanners -------------
function looksLikeSecretName(s) {
  var t = (s||"").toLowerCase();
  return (t.indexOf("pass")>=0 || t.indexOf("secret")>=0 || t.indexOf("token")>=0 || /\bkey\b/.test(t));
}

function scanScript(workflow, itemName, codeRaw, encoded, itemType) {
  var code = encoded ? b64decode(codeRaw) : safeStr(codeRaw);
  var findings = [];
  if (verbose) {
    var len = code.length;
    System.log("  • Inspecting script: item=\"" + safeStr(itemName) + "\" type=" + safeStr(itemType) + " len=" + len + (encoded ? " (base64)" : ""));
  }
  for (var p=0; p<patterns.length; p++) {
    var re = patterns[p];
    var m;
    re.lastIndex = 0;
    var hitCountForPattern = 0;
    while ((m = re.exec(code)) !== null) {
      var idx = m.index || 0;
      var lc = lineCol(code, idx);
      var snippet = mkSnippet(code, idx, m[0].length);

      var pr = new Properties();
      pr.put("workflowId", workflow.id);
      pr.put("workflowName", workflow.name);
      pr.put("category", workflow.category);
      pr.put("version", workflow.version);
      pr.put("findingType", "script_hardcoded_secret");
      pr.put("itemName", itemName || "");
      pr.put("itemType", itemType || "");
      pr.put("pattern", re.toString());
      pr.put("line", lc.line);
      pr.put("column", lc.col);
      pr.put("snippet", snippet);
      findings.push(pr);

      hitCountForPattern++;
      // guard against zero-length regex loops
      if (re.lastIndex === idx) re.lastIndex++;
    }
    if (hitCountForPattern > 0 && verbose) {
      System.warn("    ↳ Pattern hit: " + re + " (matches=" + hitCountForPattern + ")");
    }
  }
  return findings;
}

function attrValuePreview(ra) {
  // best-effort to preview short value (if present and not secret)
  try {
    if (ra && ra.value != null) {
      var v = ra.value;
      // v can be primitive or object depending on type serialization; keep it short
      var s = JSON.stringify(v);
      if (s && s.length > 120) s = s.substring(0, 120) + "…";
      return s;
    }
  } catch (e) {}
  return "";
}

function scanWorkflowContent(wf) {
  var path = api + "/workflows/" + wf.id + "/content";
  var content = getJson(path);

  var out = [];

  var items = content["workflow-item"] || [];
  var attrs = content["attrib"] || [];
  var inputs = (content.input && content.input.param) ? content.input.param : [];

  System.log("→ Scanning workflow: \"" + wf.name + "\" (id=" + wf.id + ", category=\"" + wf.category + "\", version=\"" + wf.version + "\")");
  System.log("  Items=" + items.length + ", Attributes=" + attrs.length + ", Inputs=" + inputs.length);

  // 1) Scriptable tasks & iteration catch blocks
  for (var i=0;i<items.length;i++) {
    var it = items[i];
    var iname = it.name || it["display-name"] || it.type || ("item#" + i);
    var itype = it.type || "";
    if (it.script && (it.script.value || it.script.encoded)) {
      var encoded = (it.script.encoded === true);
      out = out.concat( scanScript(wf, iname, it.script.value, encoded, itype) );
    } else if (verbose) {
      System.log("  • Skipping item (no script): " + iname + " type=" + safeStr(itype));
    }
    if (it["iteration-catch-block"] && it["iteration-catch-block"].script) {
      var sc = it["iteration-catch-block"].script;
      var encoded2 = (sc.encoded === true);
      out = out.concat( scanScript(wf, iname + " [iteration-catch]", sc.value, encoded2, itype) );
    }
  }

  // 2) Attributes with suspicious naming and not encrypted
  for (var a=0;a<attrs.length;a++) {
    var ra = attrs[a];
    var encrypt = (ra["encrypt-value"] === true);
    var nm = safeStr(ra.name);
    var typ = safeStr(ra.type);
    if (!encrypt && looksLikeSecretName(nm)) {
      var pr = new Properties();
      pr.put("workflowId", wf.id);
      pr.put("workflowName", wf.name);
      pr.put("category", wf.category);
      pr.put("version", wf.version);
      pr.put("findingType", "attribute_unencrypted");
      pr.put("itemName", nm);
      pr.put("itemType", "attribute");
      pr.put("pattern", "name≈secret & encrypt-value=false");
      pr.put("line", -1);
      pr.put("column", -1);
      pr.put("snippet", "type=" + typ + " valuePreview=" + attrValuePreview(ra));
      out.push(pr);
      if (verbose) System.warn("  • Attribute looks sensitive and is NOT encrypted: " + nm + " (type=" + typ + ")");
    } else if (verbose && looksLikeSecretName(nm)) {
      System.log("  • Attribute named like secret but encrypted=true: " + nm + " (OK)");
    }
  }

  // 3) Inputs named like secrets (risk: accidental bindings)
  for (var j=0;j<inputs.length;j++) {
    var ip = inputs[j];
    var nm2 = safeStr(ip.name);
    if (looksLikeSecretName(nm2)) {
      var pr2 = new Properties();
      pr2.put("workflowId", wf.id);
      pr2.put("workflowName", wf.name);
      pr2.put("category", wf.category);
      pr2.put("version", wf.version);
      pr2.put("findingType", "input_secret_named");
      pr2.put("itemName", nm2);
      pr2.put("itemType", "input");
      pr2.put("pattern", "input name≈secret");
      pr2.put("line", -1);
      pr2.put("column", -1);
      pr2.put("snippet", "type=" + safeStr(ip.type));
      out.push(pr2);
      if (verbose) System.warn("  • Input named like a secret: " + nm2 + " (type=" + safeStr(ip.type) + ")");
    }
  }

  System.log("  Summary for \"" + wf.name + "\": findings=" + out.length);
  return out;
}

// ------------- MAIN -------------
System.log("============================================================");
System.log("vRO Secret Scanner start: " + nowIso());
System.log("REST host: " + vroHost.url + " | pageSize=" + maxPageSize + " | throttleMs=" + throttleMs + " | verbose=" + verbose);
System.log("Patterns loaded: " + patterns.length);

var tStart = Packages.java.lang.System.nanoTime();
var findings = [];

try {
  var all = listAllWorkflows();
  var total = all.length;
  var perWfSummary = {}; // wfId -> count
  var typeSummary = {};  // findingType -> count
  var patternSummary = {}; // pattern -> count

  for (var w=0; w<total; w++) {
    var wf = all[w];
    System.log("------------------------------------------------------------");
    System.log("[" + (w+1) + "/" + total + "] " + wf.name + " (id=" + wf.id + ")");
    try {
      var f = scanWorkflowContent(wf);
      // Summaries
      if (f && f.length) {
        findings = findings.concat(f);
        perWfSummary[wf.id] = (perWfSummary[wf.id] || 0) + f.length;
        for (var i=0;i<f.length;i++) {
          var ft = f[i].get("findingType");
          typeSummary[ft] = (typeSummary[ft] || 0) + 1;
          var pat = f[i].get("pattern");
          patternSummary[pat] = (patternSummary[pat] || 0) + 1;
        }
      }
    } catch (e) {
      System.error("Error scanning workflow " + wf.id + ": " + e);
      var pr = new Properties();
      pr.put("workflowId", wf.id);
      pr.put("workflowName", wf.name);
      pr.put("category", wf.category);
      pr.put("version", wf.version);
      pr.put("findingType", "error_fetching_content");
      pr.put("itemName", "");
      pr.put("itemType", "");
      pr.put("pattern", "");
      pr.put("line", -1);
      pr.put("column", -1);
      pr.put("snippet", safeStr(e));
      findings.push(pr);
      typeSummary["error_fetching_content"] = (typeSummary["error_fetching_content"] || 0) + 1;
    }
  }

  // --------- Final Report Logs ---------
  System.log("============================================================");
  var durationMs = Math.round((Packages.java.lang.System.nanoTime() - tStart) / 1e6);
  var wfPerMin = (total > 0) ? Math.round((total / (durationMs/60000.0))*10)/10 : 0;
  System.log("Scan completed at " + nowIso());
  System.log("Workflows scanned: " + total + " | Findings: " + findings.length + " | Duration: " + durationMs + " ms (~" + wfPerMin + " wf/min)");

  // Type breakdown
  System.log("---- Findings by Type ----");
  for (var t in typeSummary) {
    System.log("  " + t + ": " + typeSummary[t]);
  }
  if (Object.keys(typeSummary).length === 0) System.log("  (none)");

  // Top patterns
  System.log("---- Top Patterns ----");
  var pats = [];
  for (var p in patternSummary) { pats.push({k:p, v:patternSummary[p]}); }
  pats.sort(function(a,b){ return b.v - a.v; });
  for (var i2=0; i2<Math.min(10, pats.length); i2++) {
    System.log("  " + pats[i2].k + " => " + pats[i2].v);
  }
  if (pats.length === 0) System.log("  (none)");

  // Top workflows by hits
  System.log("---- Workflows with Most Findings ----");
  var wfs = [];
  for (var wid in perWfSummary) { wfs.push({k:wid, v:perWfSummary[wid]}); }
  wfs.sort(function(a,b){ return b.v - a.v; });
  for (var j=0; j<Math.min(10, wfs.length); j++) {
    var wid = wfs[j].k, cnt = wfs[j].v;
    var wfName = "(unknown)";
    // find one finding to read back the name quickly
    for (var i3=0;i3<findings.length;i3++) {
      if (findings[i3].get("workflowId") === wid) { wfName = findings[i3].get("workflowName"); break; }
    }
    System.log("  " + wfName + " (" + wid + "): " + cnt);
  }
  if (wfs.length === 0) System.log("  (none)");

} catch (eOuter) {
  System.error("FATAL: " + eOuter);
}

if (findings.length === 0) {
  System.log("✅ No potential secrets found.");
} else {
  System.warn("⚠️ Total potential issues found: " + findings.length);
  if (!verbose) {
    System.warn("Tip: run with verbose=true for per-item detail and line/column annotations.");
  }
}

// Return full findings array for downstream use (CSV/export/etc.)
findings;
